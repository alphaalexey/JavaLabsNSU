# TODO list по версии ChatGPT o4-mini-high

## 1. Модуль **lab5-common**

1. **Упрощение маркеров протокола**
   Сейчас вы различаете XML vs Serialization по булеву флагу `useSerialization`. Можно сделать

   ```java
   enum Protocol { XML, JAVA_SER }
   ```

   и передавать `Protocol` вместо `boolean`, чтобы код читался понятнее.

3. **Sealed-интерфейсы (Java 17+)**
   Поскольку у вас ограниченный набор реализации для `Command`, `Event` и `Response`, можно объявить их как `sealed interface Command permits LoginCommand, …` — это добавит проверку на уровне компилятора.

---

## 2. **Gradle-скрипты**

1. **Единообразие версий**
   Лучше вынести `java { … }` и BOM-платформу Log4j в корневой `build.gradle.kts`, а не дублировать в каждом подпроекте.

2. **Добавить проверку кодирования**
   В `java {}` указать

   ```kotlin
   withSourcesJar()
   tasks.withType<JavaCompile> { options.encoding = "UTF-8" }
   ```

   чтобы гарантировать единый набор исходников и корректное чтение файлов.

3. **Версии зависимостей (libs.versions.toml)**
   Убедитесь, что все версии — в `gradle/libs.versions.toml`, а в `build.gradle.kts` используются только алиасы.

---

## 3. **ChatClient**

1. **DRY для потоков ввода-вывода**
   Большая часть кода для сериализации и для XML почти одинаковая (отправка/приём команд, парсинг ответа). Вынесите общий алгоритм в абстрактный слой — интерфейс `Transport` с двумя реализациями `XmlTransport` и `SerTransport`.

2. **Обработка ошибок протокола**
   Сейчас при несовпадении протокола вы делаете `System.exit(1)`. Лучше выбрасывать своё исключение (`ProtocolMismatchException`) и обрабатывать его в `Main`, показывая юзеру диалог, но не убивая JVM «силой».

3. **Безопасное закрытие**
   В `cleanup()` стоит явно закрывать все три–четыре потоковых объекта (`objIn`, `objOut`, `dataIn`, `dataOut`) в `try-with-resources` либо вызвать `close()` в `finally`. Иначе могут остаться «висящие» дескрипторы.

4. **Поток `incomingLoop`**

   * Добавьте флаг `volatile boolean running` и возможность корректной остановки (например, при `logout`).
   * Ловите `EOFException` отдельно и закрывайте соединение без многословного лога.

5. **UI-разделение ответственности**
   Сейчас в `ChatClient` смешаны Swing-компоненты, I/O и логика работы с протоколом. Хорошо бы:

   * Вынести Swing-UI в отдельный класс (например, `ChatWindow`).
   * `ChatClient` оставить как «контроллер»/«монитор»: посылает команды и получает события.

6. **Валидация и UX**

   * Блокировать поле ввода и кнопку «Send», пока не придёт `SuccessResponse` (идентификатор сессии).
   * При ошибках (disconnect, protocol mismatch) показывать юзеру окно с предложением повторить ввод адреса/протокола, а не сразу выходить.

---

## 4. **ChatServer & ClientHandler**

1. **Ограничение истории**
   Список `history` неограниченного размера может привести к OOM. Завести максимум, например, 1000 сообщений, и при добавлении старые удалять.

2. **Параллелизм и блокировки**

   * `synchronized` на методах `ChatServer` работает, но при большом числе клиентов централизованное блокирование — узкое место. Рассмотрите `ConcurrentHashMap` для клиентов и `CopyOnWriteArrayList`/`LinkedBlockingDeque` для истории.

3. **Graceful shutdown**
   Сервер пока «игнорирует» `SIGINT`. Можно добавить `shutdown hook`, который корректно закроет `ServerSocket` и разошлёт всем клиентам `UserLogoutEvent`, прежде чем завершиться.

4. **Повторная регистрация**
   Метод `registerClient` проверяет только по `sessionId`. Но если два клиента одновременно с разным `sessionId`, но одинаковым `userName`, вы пойдёте дальше и дважды добавите одно и то же имя. Лучше хранить `Map<String userName, ClientHandler>` или проверять уникальность `userName`.

5. **Логирование**
   В `ClientHandler.sendXml…` и других «тихих» методах исключения игнорируются. Стоит хотя бы `logger.warn` или `logger.debug` с причиной, чтобы понимать, почему не ушло сообщение.

---

### Итог

* **Разделите** транспортный уровень (XML vs Java-SE) и UI/бизнес-логику
* **Улучшите** обработку ошибок и корректный shutdown
* **Ограничьте** размер истории и сделайте безопасные коллекции
* **Упорядочьте** Gradle-конфигурацию и вынесите общие настройки в корень

Эти правки сделают код более поддерживаемым, читабельным и устойчивым к ошибкам при дальнейшем развитии проекта.
